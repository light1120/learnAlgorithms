## BitMap算法

### 算法思想
- 用bit数组来记录0/1两种状态，然后将具体数据映射到这个数组的具体位置，设置0表示数据不存在，设置1表示数据存在
- [漫画：Bitmap算法](https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg)

### 原理
- 初始化指定长度bitmap，每个bit位表示0-n的整数
- 每次把数据x存入bitmap，就将bitmap第x个bit位设置1。
- 存储结束之后，可以通过bitmap清楚查询哪些数据有被存储
- 还可以在存储前查询是否已经有数据，去除掉重复的数据

### 特点
- 处理大量数据时，提高性能
  - 一般一个整数需要4个byte来存储，如果使用bitmap只需要1个bit
  - 内存消耗会有32倍的提升
- 不适合较少数据
  - 例如：处理100000000（1亿）这个数据至少需要（100000000/32/1024/1024=2.98M）bitmap, 而正常只需4个byte

### 案例
- 给定10亿个不重复的正int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那10亿个数当中
  - 解法：遍历40个亿数字，映射到BitMap中，然后对于给出的数，直接判断指定的位上存在不存在即可
- 在2.5亿个整数中找出不重复的正整数，注，内存不足以容纳这2.5亿个整数
  - 解法1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。
  - 解法2：采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数。
  - 解法3：分治+Hash取模，拆分成多个小文件，然后一个个文件读取，直到内存装的下，然后采用Hash+Count的方式判断即可。
- 如果不是整数，而是大量文件，图片，怎么找到不重复
  - 将文件进行MD5，然后将MD5值，再继续使用bitmap存储，做重复检测